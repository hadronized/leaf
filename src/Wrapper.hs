module Wrapper where

import Control.Monad
import Data.List (intercalate)
import Data.List.Split
import HTML
import StyleSheet
import System.Directory (doesFileExist)
import System.IO

-- a wrapper is just a function that takes content and put it in a
-- page
type Wrapper = [Element] -> Page

-- construct a simple name with intercalated nick
prettyName :: (String,String,String) -> String
prettyName (f,l,n) = intercalate (" '" ++ n ++ "' ") [f,l]

-- take the first name, the last name and the nick of the portfolio, then
-- the slogan, and make a header like this below:
--
-- Dimitri 'skp' Sabadie
--       Hello, world!
header :: String -> String -> Element
header fln s = Element Div [styleWrapperHeader] [titleElem,slogElem]
    where titleElem  = Element (Header 1 $ fln) [styleWrapperHeaderTitle] []
          slogElem   = Element (Paragraph s) [styleWrapperHeaderSlog] []

-- take the name of the porfolio, the range year and make a footer
footer :: String -> Int -> Maybe Int -> Element
footer fln start rangeEnd = Element Div [styleWrapperFooter] [copyright,generator]
  where copyright  = Element (Header 4 $ "(C) " ++ fln ++ ", (" ++ show start ++ maybeRange ++ ")") [styleWrapperFooterCopyright] []
        generator  = Element (Paragraph "Generated by Leaf.") [styleWrapperFooterGenerator] []
        maybeRange = case rangeEnd of
                       Just end -> "-" ++ show end
                       _        -> ""

-- make a navbar
navbar :: [Element] -> Element
navbar links = Element Div [styleWrapperNavbar] ul
  where lis = map (\e -> Element ListItem [styleWrapperNavbarItem] [e]) links
        ul  = return $ Element UnorderedList [styleWrapperNavbarTab] lis
        
-- a wrapper is a actually a function that takes a list of
-- elements, representing the per-page content, and makes the below
-- list:
--   header : navbar : concat content : footer
-- it also generates the head and body elements
wrapper :: Element -> Element -> Element -> String -> [Element] -> Page
wrapper h f n t c = Element HTML [] [headElem,bodyElem]
  where headElem  = Element Head [] [metaElem,linkElem,titleElem]
        metaElem  = Element (Meta "Content-Type" "text/html; charset=utf-8") [] []
        linkElem  = Element (Link "default.css" "text/css" "stylesheet") [] []
        titleElem = Element (HeadTitle t) [] []
        bodyElem  = Element Body [styleWrapper] $ [h,n,content,f]
        content   = Element Div [styleWrapperContent] c
        
-- create a wrapper from a file
wrapperFromFile :: FilePath -> IO ()
wrapperFromFile p = do
  ok <- doesFileExist p
  if ok then load else return ()
    where load = withFile p ReadMode $ \handle -> do
                 lines <- lines `liftM` hGetContents handle
                 let pairs = map (map chomp) $ map (wordsBy (==':')) lines
                 print pairs
                 return ()
